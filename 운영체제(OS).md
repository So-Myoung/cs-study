<h3>1. 시스템 콜이 무엇인지 설명해 주세요.</h3>

```
운영체제의 커널이 제공하는 서비스에 대해 
응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스
```
<ul>
<li> 우리가 사용하는 시스템 콜의 예시를 들어주세요.</li>

```c
// 파일 조작 시스템 콜
open(): 파일 열기
read(): 파일 읽기
write(): 파일 쓰기
close(): 파일 닫기

// 프로세스 관리 시스템 콜
fork(): 새로운 프로세스 생성
exec(): 새로운 프로세스 실행
exit(): 프로세스 종료
wait(): 자식 프로세스 종료 대기

// 메모리 관리 시스템 콜
brk(), sbrk(): 힙 영역 크기 변경
mmap(), munmap(): 메모리 매핑 및 해제
```
<li> 시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.</li>

```
사용자 프로그램 실행 중 시스템 콜 요청 -> 커널 모드 전환 -> 
해당 시스템 콜 핸들러 실행 -> 커널 작업 수행 후 결과 반환 -> 사용자 모드 복귀
```

<li> 시스템 콜의 유형에 대해 설명해 주세요.</li>

```
1. 프로세스 제어(process control)
2. 파일 조작(file manipulation)
3. 장치 관리(device management)
4. 정보 유지(information maintenance)
5. 통신(communication)
```
<li> 운영체제의 Dual Mode 에 대해 설명해 주세요.</li>

```
1. 사용자 모드(User Mode)
- 일반 응용 프로그램이 실행되는 모드
- 사용자가 접근할 수 있는 영역에 제한이 있기 때문에 해당 모드에서는 하드웨어에 접근할 수 없음
2. 커널 모드(Kernel Mode)
- 시스템 콜을 처리하고 메모리 관리, 프로세스 스케줄링 등을 수행
- 운영체제가 하드웨어와 직접 상호작용
```
<li> 왜 사용자모드와 커널모드를 구분해야 하나요? </li>

```
보안(Security), 안정성(Stability), 자원 관리(Resource Management)
사용자 프로그램이 하드웨어 자원에 직접 접근하는 것을 방지하고, 
운영체제를 통해 안전하게 자원을 사용할 수 있도록 하기 위해서
```
<li> 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?</li>

```c
고유한 시스템 콜 번호를 통해 구분
ex)
read() : 0x03
write() : 0x04
-> 운영체제는 시스템 콜 테이블(System Call Table)에서 
시스템 콜 번호를 확인한 후 적절한 핸들러를 실행
```
</ul>

<h3>2. 인터럽트가 무엇인지 설명해 주세요.</h3>

```
CPU가 현재 실행 중인 작업을 중단하고, 
특정 이벤트를 우선적으로 처리하도록 하는 메커니즘
```
<ul>
<li> 인터럽트는 어떻게 처리하나요?</li>

```
인터럽트 발생 -> 현재 작업 저장 -> 인터럽트 핸들러(ISR) 실행
이전 상태 복구 -> 원래 작업 복귀
```
** 인터럽트가 너무 자주 발생하면 CPU가 계속 인터럽트를 처리해야 하므로, 
원래 수행 중이던 작업이 무기한 지연되어 기아 상태(Starvation)가 발생

<li> Polling 방식에 대해 설명해 주세요.</li>

```
CPU가 주기적으로 장치를 검사하여 일정한 조건이 만족되었 때 
송수신 등의 자료처리를 하는 방식
```
| 항목 | Polling | Interrupt |
|------|---------|----------|
| 처리 방식 | CPU가 주기적으로 상태를 검사 | 이벤트 발생 시 CPU에 알림 |
| CPU 자원 사용 | 높음 | 낮음 |
| 응답 속도 | 느림 | 빠름 |
| 주 사용처 | 간단한 시스템 | 복잡한 OS, 멀티태스킹 환경 |

<li> HW / SW 인터럽트에 대해 설명해 주세요.</li>

```
1. 하드웨어 인터럽트 (Hardware Interrupt)
- 외부 장치에서 발생하는 인터럽트
- 하드웨어 컨트롤러가 CPU에 직접 인터럽트 신호를 보냄
- 비동기적으로 발생
2. 소프트웨어 인터럽트 (Software Interrupt)
- 소프트웨어가 실행 도중 명령어를 통해 직접 발생시키는 인터럽트
- 시스템 콜(System Call)과 같은 OS 기능을 사용할 때 주로 사용
- 동기적으로 발생
```

<li> 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요? </li>

```
- 우선순위(Priority) 기반 처리
하드웨어적으로 인터럽트의 우선순위를 정하고, 우선순위가 높은 인터럽트를 먼저 처리
```
__Nested Interrupt (중첩 인터럽트)__
```
인터럽트 처리 중 더 높은 우선순위의 인터럽트가 발생하면, 
기존 인터럽트 처리를 중단하고 새로운 인터럽트를 처리한 후, 
다시 원래 인터럽트 처리를 이어감.
```
__Interrupt Masking(인터럽트 마스킹)__
```
특정 인터럽트를 일시적으로 비활성화하여, 
현재 실행 중인 인터럽트가 끝날 때까지 
새로운 인터럽트가 발생하지 않도록 막음.
```
</ul>

<h3>3. 프로세스가 무엇인가요?</h3>

```
컴퓨터에서 연속적으로 실행되고 있는 프로그램
프로그램이 메모리 상에서 실행되는 작업 단위
```
<ul>
<li> 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.</li>

```
프로그램: 일반적으로 하드 디스크 등에 저장되어 있는 실행코드, 실행 가능한 정적인 코드 자체
프로세스: 프로그램이 메모리 상에서 실행되는 작업 단위, 실행 중인 프로그램
스레드: 프로세스 내에서 실행되는 흐름의 단위
```
![image](https://github.com/user-attachments/assets/111daa68-7643-4d6f-8eb7-f525cd96d677)

<li> PCB가 무엇인가요?</li>

```
Process Control Block
운영체제가 프로세스를 관리하기 위해 각 프로세스마다 존재하는 구조체
프로세스의 중요한 정보를 저장하며, 운영체제의 커널 영역에 존재
```
```
1. PID (프로세스 ID): 프로세스를 구별하는 고유한 ID.
2. 프로세스 상태: 실행(Running), 대기(Waiting), 종료(Terminated) 등의 상태 정보.
3. 레지스터 정보: 프로세스의 CPU 실행 상태.
4. 메모리 정보: 코드, 데이터, 스택, 힙 영역의 위치.
5. 파일 디스크립터: 프로세스가 열어둔 파일 정보.
6. 스케줄링 정보: 프로세스 우선순위 및 스케줄링 큐 위치.
```
<li> 그렇다면, 스레드는 PCB를 갖고 있을까요?</li>

```
스레드는 독립적인 PCB를 가지고 있지 않지만,
TCB(Thread Control Block) 존재
```
<li> 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?</li>

```c
프로세스: fork() 시스템 콜을 사용하여 부모 프로세스의 복제본을 생성
스레드 : pthread_create()를 사용하여 같은 프로세스 내에서 새로운 실행 흐름을 생성.
하지만 많은 스레드를 생성하면 컨텍스트 스위칭(Context Switching) 오버헤드(Overhead)와 리소스 낭비가 발생할 수 있음.  
이를 해결하기 위해 스레드 풀(Thread Pool)을 사용하면, 미리 생성된 스레드를 재사용하여 자원 관리 효율성을 높일 수 있음.
** 컨텍스트 스위칭(Context Switching): CPU가 실행 중인 프로세스 또는 스레드를 전환할 때 발생하는 비용
```
<li> 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?</li>

```
- 자식 프로세스가 상태를 알리지 않고 종료될 경우
자식 프로세스의 PCB(Process Control Block)는 커널에 남아 좀비 프로세스(Zombie Process)가 됨.
자식 프로세스가 종료되면 부모 프로세스가 wait() 또는 waitpid() 시스템 콜을 호출하여 종료 상태를 수거해야 함.
- 부모 프로세스가 먼저 종료될 경우
부모가 먼저 종료되면, 자식 프로세스는 고아 프로세스(Orphan Process)가 됨
리눅스에서는 고아 프로세스를 init(PID 1) 프로세스가 자동으로 수거하여 정상적으로 실행되도록 함
```

<li> 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.</li>

```
init(PID 1) 프로세스
- 시스템 부팅 시 가장 먼저 실행되는 프로세스
- 모든 프로세스의 부모 역할을 수행
- 고아 프로세스 관리(부모가 없는 프로세스의 새로운 부모 노드가 됨)
- 좀비 프로세스를 정리
```
<li> 리눅스에서, 데몬프로세스에 대해 설명해 주세요.</li>

```
백그라운드에서 실행되며 특정 시스템 서비스를 제공하는 독립적인 프로세스
```
</ul>
